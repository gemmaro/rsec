/GENERATED BY rake gen:ref
h3
  | parse
  span.params title='params'
    ' (str)
pre.desc
  | Applied to an Rsec grammar, parses the string str. Any syntax errors are reported as INVALID_TOKEN.
h3
  | parse!
  span.params title='params'
    ' (str)
pre.desc
  | Applied to an Rsec grammar, parses the string str. Any synatx errors are reported in detail.
h3
  | r
pre.desc
  | Converts a terminal symbol (regex or string) into a token that can be processed by Rsec,
    e.g. as a value assigned to a non-terminal, or a token that can have any of the following operators
    applied to it.
i.example example:
pre.code
  code.prettyprint.lang-rb
    | utf8_tail = /[\u0080-\u00bf]/.r
      utf8_2 = /[\u00c2-\u00df]/.r  | utf8_tail
h3
  | lazy
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | A lazy parser for a rule is constructed when parsing starts. It is useful to reference a rule 
    that has not been defined yet: this applies to forward references (the rule is defined later),
    and to recursive references
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = lazy{future}
      future = 'jim'.r
      recurse = seq( lazy{recurse} , 'a' ) | 'b'
      assert_equal 'jim', parser.parse '12323'
      assert_equal 'recurse', parser.parse 'baaaaa'
h3
  | one_of
  span.params title='params'
    ' (str)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Parses one of the chars in str
i.example example:
pre.code
  code.prettyprint.lang-rb
    | multiplicative = one_of '*/%'
      assert_equal '/', multiplicative.parse '/'
      assert_equal Rsec::INVALID, actualmultiplicative.parse '+'
h3
  | one_of_
  span.params title='params'
    ' (str)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | See also #one_of#, with leading and trailing optional breakable spaces
i.example example:
pre.code
  code.prettyprint.lang-rb
    | additive = one_of_('+-')
      assert_equal '+', additive.parse('  +')
h3
  | prim
  span.params title='params'
    ' (type, options={})
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Primitive parser for numbers. The value of the expression is the number, as opposed to the textual value
    returned by other terminal symbols. Returns nil if overflow or underflow.
    There can be an optional '+' or '-' at the beginning of string except unsinged_int32 | unsinged_int64.
    type =
      :double |
      :hex_double |
      :int32 |
      :int64 |
      :unsigned_int32 |
      :unsigned_int64
    options:
      :allowed_sign => '+' | '-' | '' | '+-' (default '+-')
      :allowed_signs => (same as :allowed_sign)
      :base => integer only (default 10)
i.example example:
pre.code
  code.prettyprint.lang-rb
    | p = prim :double
      assert_equal 1.23, p.parse('1.23')
      p = prim :double, allowed_sign: '-'
      assert_equal 1.23, p.parse('1.23')
      assert_equal -1.23, p.parse('-1.23')
      assert_equal Rsec::INVALID, p.parse('+1.23')
      p = prim :int32, base: 36
      assert_equal 49713, p.parse('12cx')
h3
  | seq
  span.params title='params'
    ' (*xs)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Sequence parser. Processes a sequence of terminal or non-terminal symbols, and returns
    a list of their values as evaluated by their respective rules. (Textual strings, for terminal symbols.) 
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['a', 'b', 'c'], actualseq('a', 'b', 'c').parse('abc')
h3
  | seq_
  span.params title='params'
    ' (*xs)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Sequence parser with skippable pattern (or parser)
    option
      :skip default= /\s*/
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['a', 'b', 'c'], actualseq_('a', 'b', 'c', skip: ',').parse('a,b,c')
h3
  | symbol
  span.params title='params'
    ' (pattern, skip=/\s*/)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | A symbol is a token wrapped with optional space
h3
  | word
  span.params title='params'
    ' (pattern)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | A word is a token wrapped with word boundaries
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['yes', '3'], seq('yes', '3').parse('yes3')
      assert_equal INVALID, seq(word('yes'), '3').parse('yes3')
h3
  | map
  span.params title='params'
    ' (lambda_p=nil)
pre.desc
  | Transform result. Apply a procedure to the list generated by the rule.
    Is implicit if a rule is followed by a Ruby block.
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = /\w+/.r.map{|word| word * 2}
      assert_equal 'hellohello', parser.parse!('hello')      
h3
  | join
  span.params title='params'
    ' (inter)
pre.desc
  | "p.join('+')" parses strings like "p+p+p+p+p", and returns
    a list of 'p' interspersed with '+'.
    Note that at least 1 instance of p appears in the string.
    Sometimes it is useful to reverse the joining:
    /\s*/.r.join('p').odd parses string like " p p  p "
h3
  | |
  span.params title='params'
    ' (y)
pre.desc
  | Branch parser. Note that rsec is a 
    PEG parser generator[https://en.wikipedia.org/wiki/Parsing_expression_grammar];
    beware of the difference between PEG and CFG. Like all PEGs, 
    Rsec selects the first applicable option out of a list of choices,
    and ignores all others. 
h3
  | *
  span.params title='params'
    ' (n, begin..end)
pre.desc
  | Repeat n or in a range.
    If range.end &lt; 0, repeat at least range.begin
    (Infinity and -Infinity are considered)
h3
  | maybe
pre.desc
  | Appears 0 or 1 times, result is wrapped in an array
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = 'a'.r.maybe
      assert_equal ['a'], parser.parse('a')
      assert_equal [], parser.parse('')
h3
  | star
pre.desc
  | Kleene star, 0 or more any times. Note that like other
    PEGs[https://en.wikipedia.org/wiki/Parsing_expression_grammar], Rsec is greedy:
    Kleene stars and pluses will behave in counterintuitive ways when followed by
    another term, and may need to be replaced by recursion (x = y.star z, replaced by
    x = z | y lazy{x} )
h3
  | &
  span.params title='params'
    ' (other)
pre.desc
  | Lookahead term, note that other can be a very complex parser. Do not confuse this with
    the semantic lookahead predicates of Treetop (blocks of Ruby code affecting parsing).
h3
  | ^
  span.params title='params'
    ' (other)
pre.desc
  | Negative lookahead predicate. Unlike in Treetop, the negative lookahead term must follow
    rather than precede another term: x ^ y means "x, not followed by y". The Treetop
    expression (!x y), which means "y, which we have ruled out as an instance of x",
    is rendered in Rsec as seq( ''.r ^ x , y): empty string not followed by x, followed by y.
    Do not confuse this with
    the semantic lookahead predicates of Treetop (blocks of Ruby code affecting parsing).
h3
  | fail
  span.params title='params'
    ' (*tokens)
pre.desc
  | When parsing fails on the preceding term, show "expect tokens" error for that tokens value.
h3
  | >>
  span.params title='params'
    ' (other)
pre.desc
  | Short for seq_(parser, other)[1]. Used to ignore a preceding delimiter in evaluating the value
    of the term.
h3
  | <<
  span.params title='params'
    ' (other)
pre.desc
  | Short for seq_(parser, other)[0]. Used to ignore a following delimiter in evaluating the value
    of the term.
h3
  | eof
pre.desc
  | Should be end of input after parse. Used to identify the root non-terminal of a grammar; e.g.
    arithmetic = expr.eof means that the grammar arithmetic has expr as its root, and a parse of
    expr can only be followed by end-of-file.
h3
  | cached
pre.desc
  | Packrat parser combinator, returns a parser that caches parse result, may optimize performance
h3
  | []
  span.params title='params'
    ' (idx)
  span.constraints title='constraints' seq, seq_
pre.desc
  | Given that the result of a sequence parser is a list of all the terms recognised, this
    returns the parse result for the idx-th value in the list. This computation is shorter 
    and faster than map{|array| array[idx]}
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal 'b', seq('a', 'b', 'c')[1].parse('abc')
h3
  | unbox
  span.constraints title='constraints' seq, seq_, join, join.even, join.odd
pre.desc
  | If parse result contains only 1 element, return the element instead of the array.
h3
  | inner
pre.desc
  | Think of "innerHTML"! Ignore the initial and the final values in the list returned
    by a sequence parser.
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = seq('&lt;b&gt;', /[\w\s]+/, '&lt;/b&gt;').inner
      parser.parse('&lt;b&gt;the inside&lt;/b&gt;')
h3
  | even
  span.constraints title='constraints' join
pre.desc
  | Operating on the results of join, keeps only the even (left, token) parts.
    For example, unit.join(/\s+/) creates a list of [unit, \s+, unit, \s+, unit...];
    unit.join(/\s+/).even only retains [unit, unit, unit...]
h3
  | odd
  span.constraints title='constraints' join
pre.desc
  | Operating on the results of join, keeps only the odd (right, inter) parts
h3
  | until
  span.constraints title='constraints' r
pre.desc
  | Scan until the pattern happens. (Corresponds to StringScanner.scan_until.) So
    x.until parses from the current point up to and including the pattern in x;
    x.until corresponds to a non-greedy .*? x
h3
  | _?
pre.desc
  | alias for maybe
h3
  | expect
pre.desc
  | alias for fail
